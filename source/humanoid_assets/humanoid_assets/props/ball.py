from __future__ import annotations

import isaaclab.sim as sim_utils
from isaaclab.assets import RigidObjectCfg

# NOTE: parameters generated by chatgpt
# parameters to play with:
#   - activate_contact_sensors
#   - visual_material
BALL_CFG = RigidObjectCfg(
    prim_path="/{ENV_REGEX_NS}/Ball",
    spawn=sim_utils.SphereCfg(
        radius=0.11,
        mass_props=sim_utils.MassPropertiesCfg(mass=0.43),
        rigid_props=sim_utils.RigidBodyPropertiesCfg( # all properties are default None
            rigid_body_enabled=True,
            linear_damping=0.02,
            angular_damping=0.2,
            enable_gyroscopic_forces=True, # keep gyroscopic forces on for realistic spin
            sleep_threshold=1e-5, # low so ball doesn't sleep too aggressively
            # kinematic_enabled=False, # a kinematic body is a body that is moved through animated poses or through user defined poses.
            # disable_gravity=False,
            # max_linear_velocity=None,
            # max_angular_velocity=None,
            # max_depenetration_velocity=None,
            # max_contact_impulse=None,
            # retain_accelerations=None,
            # solver_position_iteration_count=None,
            # solver_velocity_iteration_count=None,
            # stabilization_threshold=None,
        ),
        collision_props=sim_utils.CollisionPropertiesCfg(
            collision_enabled=True, # whether to enable or disable collisions.
            contact_offset=0.005,   # contact offset (in m). if two objects are closer than the sum of their contact offsets, contact generation begins
            # rest_offset=None,     # rest offset (in m). the sum of two objects rest offset is how "close" they can be while stay
            torsional_patch_radius=0.02,        # the size of the contact patch the solver uses to turn penetration into a resisting twist torque. 0 is effectively "off"
            min_torsional_patch_radius = 0.005, # a floor so the effective patch doesnâ€™t collapse to ~0 on very light contacts (edges, tiny normal force)

        ),
        physics_material=sim_utils.RigidBodyMaterialCfg(
            static_friction=0.35,
            dynamic_friction=0.25,
            restitution=0.78,
            restitution_combine_mode="max", # ['average', 'min', 'multiply', 'max'] - the way restitution will be combined during collisions
            # friction_combine_mode="average",    # ['average', 'min', 'multiply', 'max'] - the way friction will be combined during collisions
            compliant_contact_stiffness=1e4,    # like a spring, similar to spring constant (higher -> stiffer)
            compliant_contact_damping=15,       # how much energy is lost after compressing
        ),
        # visible=True,
        # semantic_tags=None
        # copy_from_source=True,
        # activate_contact_sensors=False,
        # visual_material=None,
        # physics_material_path=None,
    ),
    # collision_group=0, # 0 - collide only within env, 1 - collide within scene
    # debug_vis=False, # whether to enable debug visualization
    init_state=RigidObjectCfg.InitialStateCfg(
        pos=(0, 0, 0.11),
        # rot=(1.0, 0.0, 0.0, 0.0),
        # lin_vel=(0.0, 0.0, 0.0),
        # ang_vel=(0.0, 0.0, 0.0),
    ),
)
